# SigmaZ_funcs

This package is used primarily to calculate offline SigmaZ diagrams along a specified cross-section, and from there to output the associated depth- and density- space AMOC streamfunctions and timeseries, as described in our paper Zhang and Thomas, 2021, Nat Comm Earth Env. (https://www.nature.com/articles/s43247-021-00182-y). It requires Raf Dussin's sectionate tool (https://github.com/MDTocean/sectionate), John Krasting's momlevel (https://github.com/jkrasting/momlevel), as well as some other packages that can be installed directly with pip or conda. The example .ipynb scripts showcase its usage with various model types. Note that the best sectionate version to use with this package is my version of it, called dev_MDT on my github (https://github.com/MDTocean/sectionate). 
The functions in the SigmaZ package are ordered to follow a workflow of: load (which reads the data along the specified cross sections), calculate (which calculates the SigmaZ diagram from the cross-sections), and plot (some standard streamfunctions, timeseries and SigmaZ diagrams). Some additional functions included are used to calculate SigmaZ diagrams of heat and freshwater transport (and partition MHT and MFT into MOC and gyre components), and some other functions called upon by the main functions (such as rebinning the staggered vertical coordinate onto a regular one). 

The package might look long, but much of it (especially in the load function) is housekeeping stuff, such as: cutting down the arrays to more manageable areas; making sure all grid and variable metadata are matching and consistent with each other (not always the case!); making sure everything has the correct name; or resaving data to more manageable output. Since early iterations of this package were written using numpy, I have also retained a lot of that code behind a 'numpy_algo' logical flag -- this makes the code longer, and while it will be redundant for most people, someone might want to use it at some point. There are also a lot of input variables, but most of these simply allow the user to modify e.g. the names of the grid dimensions etc -- they are defaulted to MOM6 naming conventions.  

Below are some further notes on its usage and some of its functionality. The notes are focused on the SigmaZ_diag_ReadData function, because this function loads the data and contains all of the functionality to allow for e.g. reading different model types; saving as zarr data; outputting dmget commands etc. The remaining functions in the package are relatively more straightforward, and can be more easily applied to models or observations -- they just need cross sections of V,T,S,&Rho. 


Additional notes on the SigmaZ_funcs.SigmaZ_diag_ReadData function:

1) The many input variables allow it to be flexible, and many model simulation types can be loaded in. See the example .ipync for some examples of the different model types that can be read. The function then uses the sectionate tool to output the data along anycross-section, as specified according to the section_node_lons and section_node_lats waypoints. 

2) Many of the inputs (such as variable or dimension names) are defaulted to MOM6 post-processed conventions, but these can mostly all be changed to suit other models. 

3) The zarr_dir input allows the user to input a location to output the raw data as zarr data. If zarr_dir is empty then it will do nothing; but if populated with a directory string then it will create a mirror image of the data directory, but with the zarr_dir prefix. For example, if the data directory is /location/of/the/data, then it will create new files at /zarr_dir/location/of/the/data. It will also save the data as zarr data, which is more convenient and faster -- at GFDL a good choice of zarr_dir is /xtmp/First.Last/work, since this is a fast and large directory. Every datafile read (e.g. every timestep) will be separately saved as zarr data in the new location. And if the data already exists there then it will simply read it from there instead. 

4) dmgetout is a flag for outputting the dmget commands that first need to be run before reading the data. Set to True and run the function, copy the commands into a terminal window, then set dmgetout to False and re-run when complete. 

5) filestring_identifier. This acts as a linux search-term. The code will search in the directory: dir_vars/filestring_identifier, and will search for the variables defined by rho_var, theta_var, salt_var, u_transport_var and v_transport_var (see function for descriptions). So, filestring_identifier="*" will search for everything; filestring_identifier="*.00[3-4]*" will search for everything between years 30 and 50 (i.e. it searches for everything with .003 and .004 in the filename). You can get creative with this. For example, if all variables are saved in a single variable called 'ocean_month', but each output timestep is saved in a separate folder, you could set filestring_identifier="*/*.ocean_month.nc". 

6) calc_transp (under construction): This allows transports to be calculated from velocity and cell area. Since determining the cell area requires a calculation of the partial cells, the calc_transp flag also calls on the blah function to calculate the cell area. [Needs debugging?]

7) supergrid_flag (under construction): This can be set to True if only the supergrid has been saved. It will create a regular grid from the supergrid information. [Needs debugging?]
